using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Mastermind
{
    class CodeMaker
    {
        Random rnd;
        CodeColours[] codeAnswer;

        int numPegs, numColours;

        /// <summary>
        /// Constructor for CodeMaker class
        /// Called from the Game class once a game mode has been chosen by the user
        /// Initialises several variable values and calls a method to generate the answer code
        /// </summary>
        /// <param name="random">Uses the same random number generated by the Game class to avoid generating mutliple random variables with the same / very similar seeds</param>
        /// <param name="numberOfPegs"></param>
        /// <param name="numberOfColours"></param>
        public CodeMaker(Random random, int numberOfPegs, int numberOfColours)
        {
            rnd = random;
            numPegs = numberOfPegs;
            numColours = numberOfColours;
            codeAnswer = GenerateCode();
        }

        /// <summary>
        /// Called from the constructor to generate the answer code
        /// </summary>
        /// <returns>returns the generated code as an array of CodeColours</returns>
        private CodeColours[] GenerateCode()
        {
            CodeColours[] generatedCode = new CodeColours[numPegs];
            int randomNum;

            //Using the random int variable it goes through each entry in the array and assigns it a value of the CodeColours enum equal to the random int
            for (int i = 0; i < generatedCode.Length; i++)
            {
                randomNum = rnd.Next(1, numColours + 1);
                generatedCode[i] = (CodeColours)randomNum;
            }

            return generatedCode;
        }

        /// <summary>
        /// Called once the Player or CodeBreaker class have entered a guess at the answer code
        /// Compares the guess with the answer to produce a response which is returned to the calling method
        /// </summary>
        /// <param name="playerGuess">The code guess as an array of CodeColour enum values</param>
        /// <returns>Returns the response as an array of AnswerColours enum values</returns>
        public AnswerColours[] CheckGuess(CodeColours[] playerGuess)
        {
            //The AnswerColours array which will be filled and returned as the response to the code guess
            AnswerColours[] guessAnswer = new AnswerColours[numPegs];

            //Creates lists which will hold the values from the playerGuess array and codeAnswer array
            List<CodeColours> guessList = new List<CodeColours>(), answerList = new List<CodeColours>();
            List<int> blackPegIndexes = new List<int>();

            bool removedFromList;
            int numRemoved = 0, numRight = 0;

            //First adds the entries from the arrays into the lists
            for (int i = 0; i < numPegs; i++)
            {
                guessList.Add(playerGuess[i]);
                answerList.Add(codeAnswer[i]);
            }

            //Next checks for any black peg repsonses; where a colour peg from the guess is in the same position as a peg from the answer
            //Done by looping through both lists and looks for the same CodeColour value and the same index
            //If found then a AnswerColours.B value is added to the response array and the current index is added to the integer list blackPegIndexes
            for (int i = 0; i < guessList.Count; i++)
            {
                for (int x = 0; x < answerList.Count; x++)
                {
                    if (guessList[i] == answerList[x] && i == x)
                    {
                        guessAnswer[numRight] = AnswerColours.B;
                        blackPegIndexes.Add(x);
                        numRight++;
                        break;
                    }
                }
            }

            //Once all black peg matches have been found, those pegs are removed from the guess and answer lists
            //Doing this eliminates pegs that have already generated black pegs responses from also generating white peg responses
            //Done by using the integer values in the blackPegIndexes list to do RemoveAt functions on the two lists
            for (int i = 0; i < blackPegIndexes.Count; i++)
            {
                guessList.RemoveAt(blackPegIndexes[i] - numRemoved);
                answerList.RemoveAt(blackPegIndexes[i] - numRemoved);
                numRemoved++;
            }

            //Finally check for white peg responses; where a colour peg in the guess is present in the answer but is not in the same position
            //Done by looping through both lists and checking for the same CodeColour value in each list
            //If a match is found the a white peg value is added to the response array and the value from the guess and answer lists are removed at the indexes
            //When entries are removed from the lists, the for loops are broken out of and the process is repeated within the do loop
            //this avoids entries being skipped over due to index numbers changing 
            do
            {
                removedFromList = false;
                for (int i = 0; i < guessList.Count; i++)
                {
                    for (int x = 0; x < answerList.Count; x++)
                    {
                        if (guessList[i] == answerList[x])
                        {
                            guessAnswer[numRight] = AnswerColours.W;
                            guessList.RemoveAt(i);
                            answerList.RemoveAt(x);

                            numRight++;
                            removedFromList = true;
                            break;
                        }
                    }
                    if (removedFromList) break;
                }
            }
            while (removedFromList);

            guessAnswer = guessAnswer.OrderBy(x => rnd.Next()).ToArray();
            return guessAnswer;
        }


        public CodeColours[] CodeAnswer { get { return codeAnswer; } }
    }
}
